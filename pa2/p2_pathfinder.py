def find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    frontier = [(initial_position, 0)]    previous = {}    move_cost = {}    previous[initial_position] = None    move_cost[initial_position] = 0    while frontier:        current_pos, current_cost = heappop(frontier)        if current_pos == destination:            path = []            current_path = destination            while current_path != None:                path.insert(0, current_path)                current_path = previous[current_path]            return path        for next_node, next_cost in adj(graph, current_pos):            new_cost = move_cost[current_pos] + next_cost            if next_node not in move_cost or new_cost < move_cost[next_node]:                move_cost[next_node] = new_cost                temp_cost = new_cost                heappush(frontier, (next_node, temp_cost))                previous[next_node] = current_pos    return None    path = []    boxes = {}    return path, boxes.keys()